package p2p

import (
	"bytes"
	"sync"
	"time"

	"github.com/faws-vcs/faws/faws/identity"
	"github.com/faws-vcs/faws/faws/repo/cas"
	"github.com/faws-vcs/faws/faws/repo/p2p/tracker"
	"github.com/faws-vcs/faws/faws/repo/queue"
)

type subscription struct {
	agent *Agent

	guard_manifest sync.RWMutex
	manifest_bytes []byte
	manifest_info  tracker.ManifestInfo
	manifest_time  time.Time

	topic      tracker.Topic
	repository Repository

	guard_job sync.Mutex
	job       subscription_job
	// generated by the job. but this means that peers who
	object_wishlist queue.TaskHeap[cas.ContentID]
}

func (subscription *subscription) init(agent *Agent, topic tracker.Topic, repository Repository) (err error) {
	subscription.agent = agent
	subscription.topic = topic
	subscription.repository = repository

	subscription.object_wishlist.Init()

	// subscribe to other peers
	subscription.agent.peernet_client.Subscribe(topic)

	return
}

func (subscription *subscription) shutdown() {
	subscription.guard_job.Lock()
	if subscription.job != nil {
		subscription.job.Cancel()
	}
	subscription.guard_job.Unlock()
}

// refreshes the manifest and queues
func (subscription *subscription) update_manifest() (manifest_changed bool, err error) {
	subscription.guard_manifest.Lock()
	defer subscription.guard_manifest.Unlock()
	// Download the manifest
	tracker_client := subscription.agent.peernet_client.Tracker()

	var (
		manifest_bytes []byte
		manifest       tracker.Manifest
		manifest_info  tracker.ManifestInfo
	)
	manifest_bytes, err = tracker_client.FetchManifest(subscription.topic.Hash().String())
	if err != nil {
		return
	}

	err = tracker.DecodeManifest(manifest_bytes, &manifest)
	if err != nil {
		return
	}
	// if the manifest doesn't even purport to belong to the correct identity, something is wrong with the server
	if manifest.Publisher != subscription.topic.Publisher {
		err = ErrEvilServer
		return
	}

	// again, if the server isn't checking that the manifest was signed by the identity
	// something is tampering with the server
	if !identity.Verify(subscription.topic.Publisher, &manifest.Signature, manifest.Info) {
		err = ErrEvilServer
		return
	}

	err = tracker.DecodeManifestInfo(manifest.Info, subscription.topic, &manifest_info)
	if err != nil {
		return
	}

	manifest_changed = true

	if subscription.manifest_bytes != nil {
		// ignore this manifest if it is older than the one we currently have
		// (indicates something fucked up happening, but we can manage)
		if manifest.Time().Before(subscription.manifest_time) {
			manifest_changed = false
			return
		}
		if bytes.Equal(subscription.manifest_bytes, manifest_bytes) {
			manifest_changed = false
		}
	}

	subscription.manifest_bytes = manifest_bytes
	subscription.manifest_time = manifest.Time()
	subscription.manifest_info = manifest_info

	return
}
